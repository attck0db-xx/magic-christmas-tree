<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Magic Christmas Tree</title>

<style>
html,body{
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#020205;
  font-family:"Segoe UI",system-ui;
}
#canvas{
  position:fixed;
  inset:0;
}
#loading{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  color:#ffd700;
  font-size:18px;
  letter-spacing:2px;
  background:radial-gradient(circle,rgba(0,0,0,.4),rgba(0,0,0,.9));
  z-index:10;
}
#status{
  position:fixed;
  top:16px;
  left:50%;
  transform:translateX(-50%);
  font-size:12px;
  letter-spacing:3px;
  color:#ffd700;
  opacity:.8;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
<div id="loading">✨ 正在装载圣诞记忆…</div>
<div id="status">STATE · INITIALIZING</div>
<canvas id="canvas"></canvas>

<script>
/* ===============================
   基础初始化
================================ */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020205,0.0025);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth/window.innerHeight,
  0.1,
  2000
);
camera.position.set(0,20,140);

const renderer = new THREE.WebGLRenderer({
  canvas:document.getElementById("canvas"),
  antialias:true
});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.85;

/* ===============================
   灯光（不过曝）
================================ */
scene.add(new THREE.AmbientLight(0xffffff,0.15));

const key = new THREE.PointLight(0xffb347,1.4,200);
key.position.set(0,40,30);
scene.add(key);

const rim = new THREE.DirectionalLight(0x4466ff,1.1);
rim.position.set(-50,30,-50);
scene.add(rim);

/* ===============================
   圣诞树
================================ */
const objects = [];
const geo = new THREE.SphereGeometry(1,16,16);

const mats = [
  new THREE.MeshStandardMaterial({color:0x054a25,roughness:.9}),
  new THREE.MeshStandardMaterial({color:0xffd700,metalness:.9,roughness:.3,emissive:0x442a00,emissiveIntensity:.15}),
  new THREE.MeshStandardMaterial({color:0xcc0000,metalness:.6,roughness:.4,emissive:0x330000,emissiveIntensity:.12})
];

const COUNT = 480;
const HEIGHT = 90;
const RADIUS = 38;

for(let i=0;i<COUNT;i++){
  const p=i/COUNT;
  const a=p*Math.PI*24;
  const y=HEIGHT/2-HEIGHT*p;
  const r=RADIUS*p;

  const m=new THREE.Mesh(geo,mats[Math.floor(Math.random()*mats.length)]);
  m.scale.setScalar(Math.random()*.8+.4);
  m.position.set(
    r*Math.cos(a)+(Math.random()-.5)*2,
    y,
    r*Math.sin(a)+(Math.random()-.5)*2
  );
  m.userData={y:y,phase:Math.random()*Math.PI*2};
  scene.add(m);
  objects.push(m);
}

/* ===============================
   雪花（圆形 sprite）
================================ */
function snowTex(){
  const c=document.createElement("canvas");
  c.width=c.height=64;
  const g=c.getContext("2d");
  g.fillStyle="white";
  g.beginPath();
  g.arc(32,32,18,0,Math.PI*2);
  g.fill();
  return new THREE.CanvasTexture(c);
}

const snowGeo=new THREE.BufferGeometry();
const snowCount=1800;
const pos=new Float32Array(snowCount*3);
const speed=new Float32Array(snowCount);

for(let i=0;i<snowCount;i++){
  pos[i*3]=(Math.random()-.5)*500;
  pos[i*3+1]=Math.random()*200-50;
  pos[i*3+2]=(Math.random()-.5)*500;
  speed[i]=.2+Math.random()*.4;
}
snowGeo.setAttribute("position",new THREE.BufferAttribute(pos,3));

const snow=new THREE.Points(
  snowGeo,
  new THREE.PointsMaterial({
    size:1.6,
    map:snowTex(),
    transparent:true,
    depthWrite:false,
    opacity:.9
  })
);
scene.add(snow);

/* ===============================
   动画
================================ */
function animate(){
  requestAnimationFrame(animate);
  const t=performance.now()*.001;

  objects.forEach(o=>{
    o.position.y=o.userData.y+Math.sin(t+o.userData.phase)*.6;
    o.rotation.y+=.01;
  });

  const a=snowGeo.attributes.position.array;
  for(let i=0;i<snowCount;i++){
    const id=i*3+1;
    a[id]-=speed[i];
    if(a[id]<-100) a[id]=150;
  }
  snowGeo.attributes.position.needsUpdate=true;

  renderer.render(scene,camera);
}
animate();

/* ===============================
   完成
================================ */
document.getElementById("loading").style.display="none";
document.getElementById("status").innerText="STATE · READY";

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
